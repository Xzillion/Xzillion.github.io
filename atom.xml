<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xzillion</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.bestxz.cn/"/>
  <updated>2017-11-30T14:29:34.288Z</updated>
  <id>http://www.bestxz.cn/</id>
  
  <author>
    <name>Xzillion</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>图片放大镜的分析与实现</title>
    <link href="http://www.bestxz.cn/2017/08/23/ImageZoom/"/>
    <id>http://www.bestxz.cn/2017/08/23/ImageZoom/</id>
    <published>2017-08-23T06:34:41.000Z</published>
    <updated>2017-11-30T14:29:34.288Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://odqpd0nco.bkt.clouddn.com/blog/images/imageZoom.jpg" alt="放大器"></p><blockquote><p>当我们浏览电商网站时，我们通常需要通过商品的图片来了解一些细节，但是由于内容和排版的限制，电商网站展示的都是统一尺寸规格的图片，导致我们难以从小图中观察到商品的细节。为了给顾客展示更多的商品细节，电商网站都会提供一种图片放大技术用以辅助顾客对商品进行观察。本文以图片放大技术为出发点，对主流电商网站中使用的图片放大技术进行一定的分析，并结合自身的技术积累提供了几种实现思路。</p></blockquote><h3 id="主流电商网站关于图片放大技术的实现和分析"><a href="#主流电商网站关于图片放大技术的实现和分析" class="headerlink" title="主流电商网站关于图片放大技术的实现和分析"></a>主流电商网站关于图片放大技术的实现和分析</h3><h4 id="1-淘宝图片放大技术的实现"><a href="#1-淘宝图片放大技术的实现" class="headerlink" title="1 淘宝图片放大技术的实现"></a>1 淘宝图片放大技术的实现</h4><p><img src="http://odqpd0nco.bkt.clouddn.com/blog/images/%E6%B7%98%E5%AE%9D%E5%9B%BE%E7%89%87%E6%94%BE%E5%A4%A7.png" alt="淘宝图片放大技术的实现"><br>通过简单的分析，我们可以看到这段代码里引入了一个名为imageZoom的图片处理库，该库通过监听鼠标事件对图片进行取样，并对该样本进行放大，最终将放大的样本插入到页面对应的位置。<br><a id="more"></a></p><h4 id="2-京东图片放大技术的实现"><a href="#2-京东图片放大技术的实现" class="headerlink" title="2 京东图片放大技术的实现"></a>2 京东图片放大技术的实现</h4><p><img src="http://odqpd0nco.bkt.clouddn.com/blog/images/%E4%BA%AC%E4%B8%9C%E5%9B%BE%E7%89%87%E6%94%BE%E5%A4%A7.png" alt="京东图片放大技术的实现"><br>京东的这段代码中引入了名为jqZoom的jquery插件库，该库的实现原理与imageZoom相似，动态抓取图片样本，将放大的样本插入到页面对应的位置。</p><h4 id="3-如何实现？"><a href="#3-如何实现？" class="headerlink" title="3 如何实现？"></a>3 如何实现？</h4><p>结合主流电商网站的代码实现，可以得出图片放大功能需要具备以下几点要求：</p><ul><li>动态获取图片样本</li><li>对样本进行放大</li><li>将放大后的样本插入到页面</li></ul><h3 id="图片放大技术的几种实现思路"><a href="#图片放大技术的几种实现思路" class="headerlink" title="图片放大技术的几种实现思路"></a>图片放大技术的几种实现思路</h3><h4 id="1-借助css-background-position属性实现图片放大"><a href="#1-借助css-background-position属性实现图片放大" class="headerlink" title="1 借助css background-position属性实现图片放大"></a>1 借助css background-position属性实现图片放大</h4><p>css 的 background 主要有一下几个属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    background-image: url(&quot;a.png&quot;);//图片路径</span><br><span class="line">    background-repeat: no-repeat;//如何重复展示图片</span><br><span class="line">    background-size: 100px 200px ;//图片的大小</span><br><span class="line">    background-position: center;//图片要显示的起始位置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中 background-position 属性可以设置具体的像素值，即相对于图片左上角的坐标值（以负数表示），用于选取图片的一部分进行展示，图示如下。<br><img src="http://odqpd0nco.bkt.clouddn.com/blog/images/csspostiion.png" alt="css background-position的用法图解"></p><p>雪碧图是background-position属性的一种经典实现。雪碧图是指将网页中用到的所有图标按照约定的尺寸和间距合成为一整张大图，前端网页在获取图片时，通过background-position属性截取对应位置的图标用于显示。雪碧图主要的优点是降低了网页的资源请求次数，提高了网页的解析速度。</p><p>利用background-position属性实现图片放大的过程如下：</p><ul><li>准备一张高清晰的大尺寸图片</li><li>约定大图与待取样小图的尺寸关系m</li><li>监听鼠标移动事件，获取样本的坐标</li><li>根据尺寸关系m将样本坐标映射到大图上</li><li>将映射完成的坐标设置为放大器容器的background-position值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;借助css background-position属性实现图片放大&lt;/h1&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;img id=&quot;solution-1-source&quot; src=&quot;images/food2.jpg&quot; style=&quot;cursor: zoom-in&quot;/&gt;</span><br><span class="line">    &lt;div id=&quot;solution-1-target&quot; style=&quot;display: none; background: url(&apos;images/food2.jpg&apos;) no-repeat;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    const ZOOM_BASE_NUM = 4;//放大倍数</span><br><span class="line">    const POINT_SIZE = 100;//取样点的扩散范围</span><br><span class="line">    /*借助css background-position属性实现图片放大*/</span><br><span class="line">    const SPREAD_SIZE = 400;//放大的范围，以鼠标为中心的像素值</span><br><span class="line">    let solution_1_source = document.getElementById(&quot;solution-1-source&quot;);//取样容器对象</span><br><span class="line">    let solution_1_target = document.getElementById(&quot;solution-1-target&quot;);//放大容器对象</span><br><span class="line">    let source_img = new Image();</span><br><span class="line">    source_img.src = solution_1_source.src;//获取大图对象</span><br><span class="line">    source_img.onload = ()=&gt;&#123;</span><br><span class="line">        solution_1_source.style.maxWidth = source_img.width / ZOOM_BASE_NUM + &quot;px&quot;;//将大图等比缩小，用于鼠标取样</span><br><span class="line">    &#125;</span><br><span class="line">    solution_1_target.style.width = SPREAD_SIZE + &quot;px&quot;;//设置放大器的容器大小，用于显示放大后的取样点</span><br><span class="line">    solution_1_target.style.height = SPREAD_SIZE + &quot;px&quot;;</span><br><span class="line">    solution_1_source.addEventListener(&quot;mousemove&quot;, (event) =&gt; &#123;</span><br><span class="line">        solution_1_target.style.display = &quot;inline-block&quot;;//显示放大后的取样点</span><br><span class="line">        let event_x = event.offsetX * ZOOM_BASE_NUM;//根据放大倍数将小图坐标映射到大图</span><br><span class="line">        let event_y = event.offsetY * ZOOM_BASE_NUM;</span><br><span class="line">        let position_x = ((event_x - SPREAD_SIZE / 2) &gt; 0) ? (&quot;-&quot; + (event_x - SPREAD_SIZE / 2) + &quot;px&quot;) : &quot;0&quot;;//获取放大器相对于大图的坐标</span><br><span class="line">        let position_y = ((event_y - SPREAD_SIZE / 2) &gt; 0) ? (&quot;-&quot; + (event_y - SPREAD_SIZE / 2) + &quot;px&quot;) : &quot;0&quot;;</span><br><span class="line">        solution_1_target.style.backgroundPosition = position_x + &quot; &quot; + position_y;//获取大图的一部分用于放大显示</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>此种实现方式的优点和缺点：</p><p>优点</p><ul><li>代码量较少，逻辑简单</li><li>兼容性强，不涉及第三方库和其他高级属性</li><li>只需要一张图片，资源占用少</li><li>图片读取次数少，一次加载完成即可</li></ul><p>缺点</p><ul><li>图片必须足够大，否则不利于展示</li></ul><h4 id="2-借助canvas-drawImage实现图片的放大"><a href="#2-借助canvas-drawImage实现图片的放大" class="headerlink" title="2 借助canvas drawImage实现图片的放大"></a>2 借助canvas drawImage实现图片的放大</h4><p>canvas 是 html5 引入的图像绘制API。通过canvas容器和js脚本，我们可以实现静态图像的绘制和动态画面的生成，canvas正被大量运用于图像处理和游戏制作领域。</p><p>canvas 针对图片处理的API drawImage的主要用法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">context.drawImage(img,x,y);//在画布上定位图像</span><br><span class="line">context.drawImage(img,x,y,width,height);//在画布上定位图像，并规定图像的宽度和高度</span><br><span class="line">context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height);//剪切图像，并在画布上定位被剪切的部分</span><br><span class="line"></span><br><span class="line">/*img规定要使用的图像、画布或视频。 </span><br><span class="line">sx    可选。开始剪切的 x 坐标位置。</span><br><span class="line">sy    可选。开始剪切的 y 坐标位置。</span><br><span class="line">swidth可选。被剪切图像的宽度。</span><br><span class="line">sheight可选。被剪切图像的高度。</span><br><span class="line">x    在画布上放置图像的 x 坐标位置。</span><br><span class="line">y    在画布上放置图像的 y 坐标位置。</span><br><span class="line">width可选。要使用的图像的宽度（伸展或缩小图像）。</span><br><span class="line">height可选。要使用的图像的高度（伸展或缩小图像）。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p><p>借助drawImage的第三个方法，我们可以通过以下过程实现图片的放大：</p><ul><li>获取原图对象</li><li>获取画布对象</li><li>约定图片放大倍数和取样范围</li><li>监听鼠标事件获取取样点坐标</li><li>清空画布对象</li><li>根据放大倍数、取样范围和取样点坐标在画布上绘制放大后的样本<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;借助cavans drawImage实现图片的放大&lt;/h1&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;img id=&quot;solution-2-source&quot; src=&quot;images/food1.jpg&quot; style=&quot; cursor: zoom-in&quot;&gt;</span><br><span class="line">    &lt;canvas id=&quot;solution-2-target&quot;&gt;&lt;/canvas&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    /*利用canvas drawImage实现图片的放大*/</span><br><span class="line">        let solution_2_source = document.getElementById(&quot;solution-2-source&quot;);</span><br><span class="line">        let solution_2_target = document.getElementById(&quot;solution-2-target&quot;);</span><br><span class="line">        solution_2_target.width = POINT_SIZE * ZOOM_BASE_NUM ;//根据放大倍数和扩散范围配置放大器的大小</span><br><span class="line">        solution_2_target.height = POINT_SIZE * ZOOM_BASE_NUM;</span><br><span class="line">        let canvasCtx = solution_2_target.getContext(&quot;2d&quot;);//获取canvas画布对象</span><br><span class="line">        solution_2_source.addEventListener(&quot;mousemove&quot;, (event) =&gt; &#123;</span><br><span class="line">            canvasCtx.clearRect(0, 0, POINT_SIZE * ZOOM_BASE_NUM,  POINT_SIZE * ZOOM_BASE_NUM);//清空画布</span><br><span class="line">            let event_x = event.offsetX;</span><br><span class="line">            let event_y = event.offsetY;</span><br><span class="line">            canvasCtx.drawImage(solution_2_source, event_x -  POINT_SIZE/ 2, event_y - POINT_SIZE / 2, POINT_SIZE, POINT_SIZE, 0, 0, POINT_SIZE * ZOOM_BASE_NUM, POINT_SIZE * ZOOM_BASE_NUM);</span><br><span class="line">        &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><p>此种实现方式的优点和缺点：</p><p>优点</p><ul><li>代码量最少，逻辑超简单</li><li>canvas绘制图形效率高，在某些场景降低资源消耗</li></ul><p>缺点</p><ul><li>图片尺寸没有要求，但是要足够清晰，否则放大后容易模糊</li><li>兼容性不够好，可以放弃ie了</li></ul><h4 id="3-利用svg-viewBox属性实现图片放大"><a href="#3-利用svg-viewBox属性实现图片放大" class="headerlink" title="3 利用svg viewBox属性实现图片放大"></a>3 利用svg viewBox属性实现图片放大</h4><p>SVG是一种基于可拓展标记语言实现的可缩放矢量图形，主要用于描述二维层面的矢量图形。类似于html和xml等标记语言，SVG通过属性和不同层级的标签描述对象，包括图片，文字，颜色，动画。</p><p>SVG中用于图片展示的属性viewBox的用法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//viewBox中的x y是指svg显示对象的起点坐标，width height指的是要显示对象的样本大小</span><br><span class="line">//svg的width height是指整个svg图像的大小，也就是最终样本的显示大小</span><br><span class="line"> &lt;svg  id=&quot;solution-3-target&quot; version=&quot;1.0&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;  x=&quot;0px&quot; y=&quot;0px&quot; width=&quot;&quot; height=&quot;&quot; viewBox=&quot;x y width height&quot;&gt;</span><br><span class="line">        &lt;image xlink:href=&quot;images/food1.jpg&quot; x=&quot;0px&quot; y=&quot;0px&quot;&gt;&lt;/image&gt;</span><br><span class="line">    &lt;/svg&gt;</span><br></pre></td></tr></table></figure></p><p>简单来说，可以将svg的viewBox理解为取样器，取样目标是svg内的image对象，通过设置viewBox相对于image的值选取样本，svg则负责将样本显示。</p><p>借助SVG的viewBox属性实现图片的放大主要过程如下：</p><ul><li>获取原图对象</li><li>获取svg对象</li><li>约定放大倍数和取样范围</li><li>根据放大倍数和取样范围设置svg的显示范围</li><li>将内置image对象的尺寸设置为原图的尺寸</li><li>监听鼠标事件获取取样点坐标</li><li>根据取样点坐标和取样范围动态设置svg的viewBox属性值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;借助svg viewBox属性实现图片放大&lt;/h1&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;img id=&quot;solution-3-source&quot; src=&quot;images/food1.jpg&quot; style=&quot;cursor: zoom-in&quot;&gt;</span><br><span class="line">    &lt;svg  id=&quot;solution-3-target&quot; version=&quot;1.0&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;  x=&quot;0px&quot; y=&quot;0px&quot;&gt;</span><br><span class="line">        &lt;image xlink:href=&quot;images/food1.jpg&quot; x=&quot;0px&quot; y=&quot;0px&quot;&gt;&lt;/image&gt;</span><br><span class="line">    &lt;/svg&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">     /*利用svg viewBox属性实现图片放大*/</span><br><span class="line">        let solution_3_source = document.getElementById(&quot;solution-3-source&quot;);</span><br><span class="line">        let solution_3_target = document.getElementById(&quot;solution-3-target&quot;);</span><br><span class="line">        solution_3_target.setAttribute(&quot;width&quot;, POINT_SIZE * ZOOM_BASE_NUM + &quot;px&quot;);//根据放大倍数和扩散范围配置放大器容器大小</span><br><span class="line">        solution_3_target.setAttribute(&quot;height&quot;, POINT_SIZE * ZOOM_BASE_NUM + &quot;px&quot;);</span><br><span class="line">        solution_3_source.onload = ()=&gt;&#123;</span><br><span class="line">            solution_3_target.children[0].setAttribute(&quot;width&quot;, solution_3_source.width + &quot;px&quot;);//原图尺寸和svg内待取样image元素的尺寸必须一致，否则会导致取样点偏移</span><br><span class="line">            solution_3_target.children[0].setAttribute(&quot;height&quot;, solution_3_source.height + &quot;px&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        solution_3_source.addEventListener(&quot;mousemove&quot;, (event)=&gt;&#123;</span><br><span class="line">            let event_x = event.offsetX;</span><br><span class="line">            let event_y = event.offsetY;</span><br><span class="line">            solution_3_target.setAttribute(&quot;viewBox&quot;, &quot;&quot; + (event_x - POINT_SIZE/2) + &quot; &quot; + (event_y - POINT_SIZE/2) + &quot; &quot; +POINT_SIZE + &quot; &quot; +POINT_SIZE);</span><br><span class="line">        &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><p>此种实现方式的优点和缺点：</p><p>优点</p><ul><li>代码量较少，逻辑简单</li><li>svg兼容性强，大部分浏览器都支持</li><li>性能较好，无需对图片进行反复读取</li><li>只需要利用一张图片，资源占用少</li></ul><p>缺点</p><ul><li>图片尺寸没有要求，但是要足够清晰，否则放大后容易模糊</li></ul><h3 id="一些链接"><a href="#一些链接" class="headerlink" title="一些链接"></a>一些链接</h3><ul><li><a href="http://blog.bestxz.cn/frontTec/ImageZoom.html" target="_blank" rel="noopener">图片放大器的几种实现方式</a></li><li><a href="http://www.cnblogs.com/zgqys1980/p/4308434.html" target="_blank" rel="noopener">css background-position的用法</a></li><li><a href="http://www.runoob.com/tags/canvas-drawimage.html" target="_blank" rel="noopener">html5 canvas drawImage的用法</a></li><li><a href="http://www.cnblogs.com/sunkunqi/p/5497633.html" target="_blank" rel="noopener">如何动态插入图片到svg</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://odqpd0nco.bkt.clouddn.com/blog/images/imageZoom.jpg&quot; alt=&quot;放大器&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当我们浏览电商网站时，我们通常需要通过商品的图片来了解一些细节，但是由于内容和排版的限制，电商网站展示的都是统一尺寸规格的图片，导致我们难以从小图中观察到商品的细节。为了给顾客展示更多的商品细节，电商网站都会提供一种图片放大技术用以辅助顾客对商品进行观察。本文以图片放大技术为出发点，对主流电商网站中使用的图片放大技术进行一定的分析，并结合自身的技术积累提供了几种实现思路。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;主流电商网站关于图片放大技术的实现和分析&quot;&gt;&lt;a href=&quot;#主流电商网站关于图片放大技术的实现和分析&quot; class=&quot;headerlink&quot; title=&quot;主流电商网站关于图片放大技术的实现和分析&quot;&gt;&lt;/a&gt;主流电商网站关于图片放大技术的实现和分析&lt;/h3&gt;&lt;h4 id=&quot;1-淘宝图片放大技术的实现&quot;&gt;&lt;a href=&quot;#1-淘宝图片放大技术的实现&quot; class=&quot;headerlink&quot; title=&quot;1 淘宝图片放大技术的实现&quot;&gt;&lt;/a&gt;1 淘宝图片放大技术的实现&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;http://odqpd0nco.bkt.clouddn.com/blog/images/%E6%B7%98%E5%AE%9D%E5%9B%BE%E7%89%87%E6%94%BE%E5%A4%A7.png&quot; alt=&quot;淘宝图片放大技术的实现&quot;&gt;&lt;br&gt;通过简单的分析，我们可以看到这段代码里引入了一个名为imageZoom的图片处理库，该库通过监听鼠标事件对图片进行取样，并对该样本进行放大，最终将放大的样本插入到页面对应的位置。&lt;br&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://www.bestxz.cn/tags/JavaScript/"/>
    
      <category term="idea" scheme="http://www.bestxz.cn/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>JQuery对象和Dom对象</title>
    <link href="http://www.bestxz.cn/2017/05/12/JQuery-Object-and-Dom-Object/"/>
    <id>http://www.bestxz.cn/2017/05/12/JQuery-Object-and-Dom-Object/</id>
    <published>2017-05-12T02:19:07.000Z</published>
    <updated>2017-11-30T13:58:03.342Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于JQuery对象"><a href="#关于JQuery对象" class="headerlink" title="关于JQuery对象"></a>关于JQuery对象</h3><p>通常我们说一个xx类的对象时，一般指代的是使用这个类的某种构造方法构造的对象，如Java中的String字符串对象，一般是通过String类的构造方法public String(String original)构造的，在JQuery中也存在类似的概念。<br>在JQuery中有一个构造器$()(也可写作jQuery()),他可以接收一个字符串或者特定的Dom对象，用于构造一个JQuery对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//接收字符串的构造形式</span><br><span class="line">$(&apos;span&apos;);//构造一个JQuery对象，用于操作当前文档中所有的span标签</span><br><span class="line">$(&apos;.myclass&apos;)//通过css的类选择器构造一个JQuery对象，用于操作当前文档中所有class为&quot;myclass&quot;的元素</span><br><span class="line">$(&apos;#myid&apos;)//通过css的id选择器构造一个JQuery对象，用于操作当前文档中id为&quot;myid&quot;的元素</span><br><span class="line">$(&quot;&lt;p class=&apos;mytext&apos;&gt;hello world&lt;/p&gt;&quot;)//通过html字符串构造一个新的Dom元素</span><br><span class="line"></span><br><span class="line">//接收特定Dom元素的构造形式</span><br><span class="line">$(document).ready(function)//通过document元素构造一个JQuery对象，用于监听页面载入完成的事件</span><br></pre></td></tr></table></figure></p><h3 id="关于Dom对象"><a href="#关于Dom对象" class="headerlink" title="关于Dom对象"></a>关于Dom对象</h3><p>Dom对象一般指代是JavaScript中内置的用于操作Dom元素的对象，包括Document,Element,Attribute和Event。</p><h4 id="1-Document"><a href="#1-Document" class="headerlink" title="1 Document"></a>1 Document</h4><p>每个载入浏览器的Html文档都会成为一个Document对象，通过Document对象，我们可以访问Html文档中所有的元素。<br>Document对象有一个最常用的方法document.getElementById(),通过此方法我们可以获取一个html元素的引用。</p><h4 id="2-Element"><a href="#2-Element" class="headerlink" title="2 Element"></a>2 Element</h4><p>Element对象表示的是Html文档中的每个元素，包括元素节点，文本节点，注释节点。<br>Document对象的getElementById()方法返回的就是一个Element对象。<br>在Dom对象中，Attribute表示Html元素的属性，它属于Html元素。我们可以通过document.getElementById(“a”).attribute(“src”)来访问id为”a”元素的”src”属性。<br><a id="more"></a></p><h4 id="3-Event"><a href="#3-Event" class="headerlink" title="3 Event"></a>3 Event</h4><p>Event对象代表事件的状态，包括事件中的元素、键盘按钮、鼠标按钮等的状态。<br>Event对象一般作用于html文档的元素，即Element对象。  </p><p>从以上定义我们可以总结出Dom对象与其子对象的关系：<br><img src="http://odqpd0nco.bkt.clouddn.com/blog/images/Dom%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%85%B3%E7%B3%BB.png" alt="Dom对象及其子对象关系图"></p><h3 id="Dom对象与JQuery对象的相互转化"><a href="#Dom对象与JQuery对象的相互转化" class="headerlink" title="Dom对象与JQuery对象的相互转化"></a>Dom对象与JQuery对象的相互转化</h3><p>Dom对象是JavaScript中内置的用于操作Dom元素的对象，JQuery对象是使用JQuery的构造器$()构造的对象。对于JQuery对象，它只能操作JQuery独有的方法，不能操作Dom对象的方法，对于Dom对象来说也是如此，它无法操作JQuery对象的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;#myid&quot;).attr(&apos;class&apos;)//通过JQuery对象的attr()方法获取元素的某个属性值</span><br><span class="line">$(&quot;#myid&quot;).getAttribute(&apos;class&apos;)//undefind,JQuery对象无法操作Dom对象的方法</span><br><span class="line">document.getElementById(&apos;myid&apos;).checked = false//Dom对象通过操作checked属性改变input元素的选中状态</span><br><span class="line">document.getElementById(&apos;myid&apos;).attr(&apos;checked&apos;,false)// Uncaught TypeError: document.getElementById(...).attr is not a function(…),Dom对象无法调用JQuery对象的方法</span><br></pre></td></tr></table></figure></p><p>在某些情况下，我们需要将Dom对象和JQuery对象互相转化。</p><h4 id="1-JQuery对象转化为Dom对象"><a href="#1-JQuery对象转化为Dom对象" class="headerlink" title="1 JQuery对象转化为Dom对象"></a>1 JQuery对象转化为Dom对象</h4><p>展开一个JQuery对象，我们通常能够得到如下的结构：<br><img src="http://odqpd0nco.bkt.clouddn.com/blog/images/JQuery%E5%AF%B9%E8%B1%A1%E5%B1%95%E5%BC%80.png" alt="JQuery对象展开形式"></p><p>可以看到一个JQuery对象的第一个属性”0”表示的正是一个Dom对象，因此通过$(“#myid”)[0]即可获取到JQuery对象对应的Dom对象。</p><h4 id="2-Dom对象转化为JQuery对象"><a href="#2-Dom对象转化为JQuery对象" class="headerlink" title="2 Dom对象转化为JQuery对象"></a>2 Dom对象转化为JQuery对象</h4><p>通过JQuery构造器$()可以将一个Dom对象转化为JQuery对象，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var domObject = document.getElementById(&quot;myid&quot;);</span><br><span class="line">var mylass = $(domObject).attr(&apos;class&apos;);</span><br></pre></td></tr></table></figure></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="http://blog.csdn.net/wangboxian/article/details/8903999" target="_blank" rel="noopener">JQuery对象与Dom对象的区别</a><br><a href="http://www.w3school.com.cn/jsref/dom_obj_document.asp" target="_blank" rel="noopener">HTML DOM对象</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;关于JQuery对象&quot;&gt;&lt;a href=&quot;#关于JQuery对象&quot; class=&quot;headerlink&quot; title=&quot;关于JQuery对象&quot;&gt;&lt;/a&gt;关于JQuery对象&lt;/h3&gt;&lt;p&gt;通常我们说一个xx类的对象时，一般指代的是使用这个类的某种构造方法构造的对象，如Java中的String字符串对象，一般是通过String类的构造方法public String(String original)构造的，在JQuery中也存在类似的概念。&lt;br&gt;在JQuery中有一个构造器$()(也可写作jQuery()),他可以接收一个字符串或者特定的Dom对象，用于构造一个JQuery对象。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//接收字符串的构造形式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$(&amp;apos;span&amp;apos;);//构造一个JQuery对象，用于操作当前文档中所有的span标签&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$(&amp;apos;.myclass&amp;apos;)//通过css的类选择器构造一个JQuery对象，用于操作当前文档中所有class为&amp;quot;myclass&amp;quot;的元素&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$(&amp;apos;#myid&amp;apos;)//通过css的id选择器构造一个JQuery对象，用于操作当前文档中id为&amp;quot;myid&amp;quot;的元素&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$(&amp;quot;&amp;lt;p class=&amp;apos;mytext&amp;apos;&amp;gt;hello world&amp;lt;/p&amp;gt;&amp;quot;)//通过html字符串构造一个新的Dom元素&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//接收特定Dom元素的构造形式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$(document).ready(function)//通过document元素构造一个JQuery对象，用于监听页面载入完成的事件&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;关于Dom对象&quot;&gt;&lt;a href=&quot;#关于Dom对象&quot; class=&quot;headerlink&quot; title=&quot;关于Dom对象&quot;&gt;&lt;/a&gt;关于Dom对象&lt;/h3&gt;&lt;p&gt;Dom对象一般指代是JavaScript中内置的用于操作Dom元素的对象，包括Document,Element,Attribute和Event。&lt;/p&gt;
&lt;h4 id=&quot;1-Document&quot;&gt;&lt;a href=&quot;#1-Document&quot; class=&quot;headerlink&quot; title=&quot;1 Document&quot;&gt;&lt;/a&gt;1 Document&lt;/h4&gt;&lt;p&gt;每个载入浏览器的Html文档都会成为一个Document对象，通过Document对象，我们可以访问Html文档中所有的元素。&lt;br&gt;Document对象有一个最常用的方法document.getElementById(),通过此方法我们可以获取一个html元素的引用。&lt;/p&gt;
&lt;h4 id=&quot;2-Element&quot;&gt;&lt;a href=&quot;#2-Element&quot; class=&quot;headerlink&quot; title=&quot;2 Element&quot;&gt;&lt;/a&gt;2 Element&lt;/h4&gt;&lt;p&gt;Element对象表示的是Html文档中的每个元素，包括元素节点，文本节点，注释节点。&lt;br&gt;Document对象的getElementById()方法返回的就是一个Element对象。&lt;br&gt;在Dom对象中，Attribute表示Html元素的属性，它属于Html元素。我们可以通过document.getElementById(“a”).attribute(“src”)来访问id为”a”元素的”src”属性。&lt;br&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://www.bestxz.cn/tags/JavaScript/"/>
    
      <category term="JQuery" scheme="http://www.bestxz.cn/tags/JQuery/"/>
    
      <category term="Dom" scheme="http://www.bestxz.cn/tags/Dom/"/>
    
  </entry>
  
  <entry>
    <title>angularJs应用如何去除路径上的#号？</title>
    <link href="http://www.bestxz.cn/2017/05/10/diary-start/"/>
    <id>http://www.bestxz.cn/2017/05/10/diary-start/</id>
    <published>2017-05-09T16:02:58.000Z</published>
    <updated>2017-11-30T13:58:03.343Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-为什么angularJs应用路径上会存在-号？"><a href="#1-为什么angularJs应用路径上会存在-号？" class="headerlink" title="1 为什么angularJs应用路径上会存在#号？"></a>1 为什么angularJs应用路径上会存在#号？</h3><p>AngularJS是单页应用，一个ng-app对应一个页面，一个URL。AngularJS实现了自己的前端路由，让一个ng-app可以管理多个URL，再对应到多个ng-vew上面。当我们去访问URL的时候，浏览器会向服务器发送request请求，若此时服务器端不存在该请求对应的文件资源，则会抛出404错误，为了解决这一问题，angularJs默认在访问路径中添加#号，使得浏览器不向服务器发送请求，转而由自带的router处理，这样就不会出现404报错问题。在reactJs框架中也存在类似的概念（hashHistory和browserHistory）。</p><h3 id="2-去除路径中存在的-号"><a href="#2-去除路径中存在的-号" class="headerlink" title="2 去除路径中存在的#号"></a>2 去除路径中存在的#号</h3><p>在1中提到，当路径中不存在#号时，浏览器会向服务端发送request请求，此时可能触发404错误，那么我们要做到去除#又不触发404错误，就必须在服务端进行一些配置。</p><h4 id="2-1-在angularJs路由配置html5Mode"><a href="#2-1-在angularJs路由配置html5Mode" class="headerlink" title="2.1 在angularJs路由配置html5Mode"></a>2.1 在angularJs路由配置html5Mode</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function routeConfig($stateProvider, $urlRouterProvider, $qProvider, $locationProvider) &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 配置路由</span><br><span class="line">     */</span><br><span class="line">    $qProvider.errorOnUnhandledRejections(false);</span><br><span class="line">    $urlRouterProvider.otherwise(&apos;home/pageOne/pageOne&apos;);//路径没有配置路由的时候默认跳转到指定路径</span><br><span class="line">    $stateProvider</span><br><span class="line">        .state(&apos;home&apos;,&#123;</span><br><span class="line">            url: &apos;/home&apos;,</span><br><span class="line">            abstract: true,</span><br><span class="line">            templateUrl: &apos;views/home.html&apos;,</span><br><span class="line">            controller: &apos;homeCtrl&apos;,</span><br><span class="line">        &#125;)</span><br><span class="line">        ........</span><br><span class="line">..........</span><br><span class="line">    $locationProvider.html5Mode(true);/*去除路由#号，为了避免请求转发到后端server触发404错误，nginx也需要相关配置*/</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2-2-在首页中配置基本路径"><a href="#2-2-在首页中配置基本路径" class="headerlink" title="2.2 在首页中配置基本路径"></a>2.2 在首页中配置基本路径</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;base href=&quot;/&quot;&gt;&lt;!--去除路由的#号--&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;renderer&quot; content=&quot;webkit|ie-comp|ie-stand&quot;&gt;</span><br><span class="line">    &lt;title&gt;classSouvenir&lt;/title&gt;</span><br><span class="line">    &lt;link href=&quot;styles/min/main.min.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div ui-view&gt;&lt;/div&gt;</span><br><span class="line">&lt;script data-main=&quot;scripts/main.min&quot; src=&quot;scripts/libs/requirejs/require.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>==注意： 若不配置基本路径，则会抛出Error: $location:nobase错误。==</p><h3 id="2-3-在服务端的配置"><a href="#2-3-在服务端的配置" class="headerlink" title="2.3 在服务端的配置"></a>2.3 在服务端的配置</h3><h4 id="2-3-1-Nginx配置"><a href="#2-3-1-Nginx配置" class="headerlink" title="2.3.1 Nginx配置"></a>2.3.1 Nginx配置</h4><p>编辑nginx的配置文件，增加try_files配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        set $htdocs /www/deploy/mysite/onbook;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name onbook.me;</span><br><span class="line">        location / &#123;</span><br><span class="line">            root $htdocs;</span><br><span class="line">            try_files $uri $uri/ /index.html =404;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-3-2-Express配置"><a href="#2-3-2-Express配置" class="headerlink" title="2.3.2 Express配置"></a>2.3.2 Express配置</h4><p>Express框架的路由访问控制文件server.js，增加路由配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.use(function (req, res) &#123;</span><br><span class="line">    console.log(req.path);</span><br><span class="line">    if(req.path.indexOf(&apos;/api&apos;)&gt;=0)&#123;</span><br><span class="line">        res.send(&quot;server text&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;else&#123; //angular启动页</span><br><span class="line">        res.sendfile(&apos;app/index.html&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>==注意：若服务端不进行配置，则用户通过url直接访问页面时显示正常，但刷新页面或者通过路由跳转时会发生找不到页面的错误。==</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-为什么angularJs应用路径上会存在-号？&quot;&gt;&lt;a href=&quot;#1-为什么angularJs应用路径上会存在-号？&quot; class=&quot;headerlink&quot; title=&quot;1 为什么angularJs应用路径上会存在#号？&quot;&gt;&lt;/a&gt;1 为什么angularJs应用路径上会存在#号？&lt;/h3&gt;&lt;p&gt;AngularJS是单页应用，一个ng-app对应一个页面，一个URL。AngularJS实现了自己的前端路由，让一个ng-app可以管理多个URL，再对应到多个ng-vew上面。当我们去访问URL的时候，浏览器会向服务器发送request请求，若此时服务器端不存在该请求对应的文件资源，则会抛出404错误，为了解决这一问题，angularJs默认在访问路径中添加#号，使得浏览器不向服务器发送请求，转而由自带的router处理，这样就不会出现404报错问题。在reactJs框架中也存在类似的概念（hashHistory和browserHistory）。&lt;/p&gt;
&lt;h3 id=&quot;2-去除路径中存在的-号&quot;&gt;&lt;a href=&quot;#2-去除路径中存在的-号&quot; class=&quot;headerlink&quot; title=&quot;2 去除路径中存在的#号&quot;&gt;&lt;/a&gt;2 去除路径中存在的#号&lt;/h3&gt;&lt;p&gt;在1中提到，当路径中不存在#号时，浏览器会向服务端发送request请求，此时可能触发404错误，那么我们要做到去除#又不触发404错误，就必须在服务端进行一些配置。&lt;/p&gt;
&lt;h4 id=&quot;2-1-在angularJs路由配置html5Mode&quot;&gt;&lt;a href=&quot;#2-1-在angularJs路由配置html5Mode&quot; class=&quot;headerlink&quot; title=&quot;2.1 在angularJs路由配置html5Mode&quot;&gt;&lt;/a&gt;2.1 在angularJs路由配置html5Mode&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function routeConfig($stateProvider, $urlRouterProvider, $qProvider, $locationProvider) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * 配置路由&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $qProvider.errorOnUnhandledRejections(false);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $urlRouterProvider.otherwise(&amp;apos;home/pageOne/pageOne&amp;apos;);//路径没有配置路由的时候默认跳转到指定路径&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $stateProvider&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .state(&amp;apos;home&amp;apos;,&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            url: &amp;apos;/home&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            abstract: true,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            templateUrl: &amp;apos;views/home.html&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            controller: &amp;apos;homeCtrl&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ........&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;..........&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $locationProvider.html5Mode(true);/*去除路由#号，为了避免请求转发到后端server触发404错误，nginx也需要相关配置*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://www.bestxz.cn/tags/JavaScript/"/>
    
      <category term="angularJs" scheme="http://www.bestxz.cn/tags/angularJs/"/>
    
      <category term="Web" scheme="http://www.bestxz.cn/tags/Web/"/>
    
  </entry>
  
</feed>
